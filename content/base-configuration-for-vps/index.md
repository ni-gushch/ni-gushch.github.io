+++
title = "Базовая настройка VPS."
description = "Перечень базовых настроек, которые желательно сразу сделать после запуска нового сервера."
date = 2025-08-24
updated = 2025-08-24
draft = false
in_search_index = true

[taxonomies]
tags = ["linux", "vps", "servers"]
[extra]
keywords = "Linux, VPS"
#thumbnail = "ferris-gesture.png"
#toc = true
series = "linux"
+++

Представь, что ты только что создал новый VPS-сервер и готов использовать его в качестве надежного шлюза для своих домашних серверов? Первые несколько минут жизни сервера — самые критичные с точки зрения безопасности. Свежие серверы в облаке — любимая мишень для автоматических сканеров и ботов.

В этом руководстве мы шаг за шагом разберем необходимый и достаточный минимум первоначальной настройки Ubuntu Server, который превратит "голую" систему в удобный и хорошо защищенный форпост для твоих сервисов. Наша цель — не только обезопасить его от атак, но и сделать работу с ним комфортной.

## Шаг 0: Предварительные требования

· VPS-сервер с установленной Ubuntu Server 22.04 LTS или 24.04 LTS.
· Root-доступ к серверу (логин и пароль, который тебе предоставил хостинг-провайдер, или SSH-ключ).
· SSH-клиент на твоем компьютере (обычно подходит стандартный терминал).

---

## Шаг 1: Первое подключение и обновление системы

Первым делом подключимся к серверу. Если провайдер предоставил пароль root, команда будет выглядеть так (нужно заменить your_server_ip на реальный IP-адрес):

```bash
ssh root@your_server_ip
```

Появится запрос на подтверждение fingerprint. Нужно ответить «yes» на вопрос о доверии fingerprint и ввести пароль.

Сразу после входа:

1. Обновляем индекс пакетов и устанавливаем обновления:
   ```bash
   apt update && apt upgrade -y
   ```
   Это гарантирует, что все системные компоненты и библиотеки имеют последние патчи безопасности.
2. Устанавливаем базовые полезные утилиты:
   ```bash
   apt install -y curl wget nano ufw fail2ban
   ```
   · **curl**, **wget** — для загрузки файлов из интернета.
   · **nano** — простой текстовый редактор для новичков (вы можете использовать vim, если знакомы с ним).
   · **ufw** — фаервол для простого управления сетевым трафиком.
   · **fail2ban** — система для блокировки bruteforce-атак (подбор паролей).
3. Перезагружаем сервер (если обновление затрагивало ядро):
   ```bash
   reboot
   ```
   Подождем минуту и подключаемся снова.

---

## Шаг 2: Создаем нового пользователя и запрещаем root-логин по SSH

Работать под `root` — плохая практика. Создадим нового пользователя с привилегированными правами.

1. Создаем пользователя (вместо username подставьте ваше имя пользователя):
   ```bash
   adduser username
   ```
   Задай надежный пароль и заполни информацию (можно пропустить).
2. Добавляем пользователя в группу sudo: Это даст ему право выполнять команды с правами root.
   ```bash
   usermod -aG sudo username
   ```
3. Настраиваем SSH-ключи для безопасного входа (рекомендуется):
   · На своем компьютере (не на сервере!) сгенерируй пару SSH-ключей, если у тебя её еще нет:
     ```bash
     ssh-keygen -t ed25519
     ```
   · Скопируй публичный ключ на сервер для твоего нового пользователя:
     ```bash
     ssh-copy-id username@your_server_ip
     ```
     (На Windows без ssh-copy-id можно скопировать содержимое файла ~/.ssh/id_ed25519.pub и вручную добавить его на сервер в файл ~/.ssh/authorized_keys).
4. Настраиваем SSH-демон для повышения безопасности: Откроем конфигурационный файл:
   ```bash
   nano /etc/ssh/sshd_config
   ```
   Найди и измени следующие директивы (если строки закомментированы #, раскомментируй их):
   ```bash
   PermitRootLogin no          # Запрещаем вход под root
   PasswordAuthentication no   # Запрещаем вход по паролю, только по ключу
   PubkeyAuthentication yes    # Разрешаем аутентификацию по ключу
   ```
   Внимание! Убедись, что твой SSH-ключ скопирован и работает, прежде чем перезапускать SSH! Иначе ты потеряете доступ. И придется заходить через админ панель хост провайдера.
5. Перезагружаем SSH-сервис для применения изменений:
   ```bash
   systemctl reload sshd
   ```
   Теперь открой новое окно терминала и попробуй подключиться как новый пользователь: ssh username@your_server_ip. Если все работает, можно закрывать сессию root.

---

## Шаг 3: Изменение стандартного порта для SSH подключения (опционально)

Изменение порта SSH по умолчанию — это не про настоящую безопасность. Безопасность в этом случае выражется через неясность (Security through obscurity). Изменение значения порта не отменяет необходимость использования `SSH-ключей` и `Fail2Ban`. Это дополнительный, очень легкий в реализации слой, который значительно снижает уровень шума от автоматических сканеров.

Безопасно ли оставлять порт 22? Да, если и только если ты уже реализовал:

1. Полный запрет на вход по паролю (PasswordAuthentication no).
2. Использование только SSH-ключей (PubkeyAuthentication yes).
3. Запрет входа под root (PermitRootLogin no).
4. Защиту с помощью Fail2Ban.

При этих условиях оставить порт 22 — абсолютно безопасное решение. Автоматические боты, сканирующие порт 22, просто будут получать отказ на попытку аутентификации и уходить ни с чем.

Хотя это и не добавляет криптографической стойкости, я настоятельно рекомендую заменить стандартный порт. Это дает практические преимущества:

1. Резкое снижение "шума" в логах. Твои логи `/var/log/auth.log` и таблица банов `Fail2Ban` не будут засоряться тысячами попыток от примитивных ботов, которые сканируют только порт `22`. Это упрощает анализ логов и снижает небольшую, но бесполезную нагрузку на систему.
2. Затруднение для целевых атак. Злоумышленник, который целенаправленно ищет твою систему, все равно найдет `SSH-порт` сканером всего диапазона портов (Nmap). Но это уже не низкоуровневый скрипт-бот, а более продвинутая атака. Вы отсекаете `99.9%` автоматического мусора.

Недостаток:

· Удобство. Тебе всегда нужно указывать нестандартный порт при подключении: `ssh -p 12345 user@server.ip`. Однако это легко решается настройкой конфига `SSH` на твоей клиентском машине.

Какой порт выбрать? Лучшие практики.

Главное правило: не выбирай порт, который занят другим известным сервисом (например, 80 — HTTP, 443 — HTTPS, 21 — FTP), чтобы не создать конфликт в будущем.

Хороший выбор:

· Порты из диапазона `1024-49151` (зарегистрированные/пользовательские).
· Избегай "модных" нестандартных портов для SSH, типа `2222`, `22222`, `22225`. Их тоже массово сканируют, потому что их популярность сделала их очевидными.
· Выбери случайное, ничем не примечательное число.

Примеры хороших портов: `53982`, `28465`, `49123`, `13574`

Примеры плохих портов: `22` (стандартный), `2222` (очевидный), `22222` (очевидный), `9022` (очевидная вариация), `21`, `80`, `443` (конфликтующие).

Как сменить порт

1. Подключись к серверу и открой конфигурационный файл SSH:
   ```bash
   sudo nano /etc/ssh/sshd_config
   ```
2. Найди строку #Port 22. Раскомментируй ее (убери знак комментария #) и измени номер порта на выбранный ранее.
   ```
   Port 53982   # Замени 53982 на свой порт
   ```
3. Сохрани файл и перезагрузи SSH-сервис.
   ```bash
   sudo systemctl reload ssh
   ```
   ВНИМАНИЕ! Не закрывай текущую сессию SSH! Убедись, что новое подключение работает.
4. Открой новое окно терминала и попробуй подключиться к серверу, указав новый порт.
   ```bash
   ssh -p 53982 username@your_server_ip
   ```
   Если подключение прошло успешно, можно закрыть старую сессию.

---

## Шаг 4: Настраиваем базовый фаервол (`UFW`)

Мы разрешим только самые необходимые порты: `SSH` для управления и позже — порт для нашей сети связывающий локальные машины и удаленный сервер.

1. Разрешаем `SSH`-соединения: Важно сделать это до включения фаервола.
   ```bash
   ufw allow OpenSSH
   ```
   Если ты планируешь использовать нестандартный порт для `SSH`, укажи его явно: `ufw allow 2222/tcp` (пример для порта 2222).
  - Если же уже был выставлен базовый порт для SSH, то обнови правила фаервола `UFW`. Сначала удали старое правило для `OpenSSH` (которое открывало порт `22`), затем добавь новое.
   ```bash
   sudo ufw delete allow OpenSSH  # Или просто 'ufw delete allow 22/tcp'
   sudo ufw allow 53982/tcp       # Разрешаем новый порт
   sudo ufw status                # Убедитесь, что порт 22 закрыт, а новый открыт
   ```
2. Включаем фаервол:
   ```bash
   ufw enable
   ```
   Ответь y. Фаервол активирован и уже блокирует все неразрешенные входящие соединения.
3. Проверяем статус:
   ```bash
   ufw status verbose
   ```
   Ты должен увидеть, что разрешен только `OpenSSH` или новый порт для `SSH`.

---

## Шаг 5: Настраиваем `Fail2Ban` для защиты от атак

`Fail2Ban` будет мониторить логи `SSH` и автоматически блокировать `IP`-адреса, которые пытаются подобрать пароль.

1. Создаем простую конфигурацию для `SSH`: Скопируем стандарнный файл настроек для `jail`:
   ```bash
   cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local
   ```
   Отредактируем его:
   ```bash
   nano /etc/fail2ban/jail.local
   ```
   В секции [sshd] убедись, что настройки выглядят так:
   ```ini
   [sshd]
   enabled = true
   port    = ssh
   logpath = %(sshd_log)s
   backend = %(sshd_backend)s
   maxretry = 3
   bantime = 1h
   findtime = 1h
   ```
   · `maxretry` = 3: количество неудачных попыток перед блокировкой.
   · `bantime` = 1h: время блокировки (1 час). Можно поставить -1 для перманентной блокировки.
   · `findtime` = 1h: окно времени, в котором считаются неудачные попытки.
2. Запускаем и активируем `Fail2Ban`:
   ```bash
   systemctl enable fail2ban --now
   ```
3. Проверяем статус:
   ```bash
   fail2ban-client status sshd
   ```
   Ты увидишь список забаненных `IP`-адресов, если атаки уже были.
4. (Важно!) Обнови конфигурацию `Fail2Ban` если был изменен стандартный порт для `SSH`. `Fail2Ban` по умолчанию следит за портом `22`. Нужно сказать ему, чтобы он смотрел на новый порт.
   · Отредактируй конфиг `Fail2Ban` для `SSH`:
   ```bash
   sudo nano /etc/fail2ban/jail.local
   ```
   · В секции [sshd] найди параметр `port` и измени его:
   ```ini
   [sshd]
   enabled = true
   port    = 53982    # Укажи свой новый порт здесь!
   # ... остальные настройки (maxretry, bantime) ...
   ```
   · Перезапусти `Fail2Ban`:
   ```bash
   sudo systemctl restart fail2ban
   ```

---

## Шаг 6: Настройка часового пояса, локали и мониторинга

1. Установим правильный часовой пояс:
   ```bash
   sudo timedatectl set-timezone Europe/Moscow  # Замените на ваш пояс
   ```
2. Установим нужную локаль (язык системы):
   ```bash
   sudo dpkg-reconfigure locales
   ```
   Выбери en_US.UTF-8 UTF-8 (рекомендуется для серверов) или ru_RU.UTF-8 UTF-8.
3. Установим утилиты для мониторинга ресурсов:
   ```bash
   sudo apt install -y htop
   ```
   htop — отличная замена стандартной top, позволяет интерактивно следить за нагрузкой на CPU, RAM и процессы.

---

## Шаг 7: (Опционально, но рекомендуется) Настройка резервного копирования

Твой VPS — это важная инфраструктура. Его поломка не должна стать катастрофой. Поэтому очень рекомендую организовать резервное копирование критически важный директорий (/etc, /home, /root). Можно использовать как встроенные утилиты, предоставляемые провайдером. Либо же создать свое хранилище, и отправлять информацию в тот же S3.

---

## Шаг 8: Можно провести аудит безопасности.

В сети есть утилиты, которые могут провести базовый аудит безопасности вашего сервера. Например есть bash script [VPS Audit](https://github.com/vernu/vps-audit). Запустив который можно получить отчет по анализу системы. Отчет сохраняется в отдельный файлик, чтобы потом можно было еще раз его проанализировать.

В рамках анализа проверяеются не только те пункты, которые мы затронули, но и такие не обычные вещи, как автоматическое обновление критически важных пакетов, или установку правила для установки пароля пользователя. Список проводимых проверок

- `System Restart` - Проветяется, нужен ли перезапуск сервера после обновления
- `SSH Root Login` - Проверка, включен ли логин из под root пользователя через SSH
- `SSH Password Auth` - Проверка, включен ли метод аутентификации SSH через пароль
- `SSH Port` - Проверяет стандартный порт для SSH, если выставлен в 22 то рекомендуется изменить
- `Firewall Status (UFW)` - Проверка статуса UFW firewall
- `Unattended Upgrades` - Проверка на автоматическое обновление пакетов безопасности
- `Intrusion Prevention` - Наличие Fail2ban или CrowdSec а так же статус их активности
- `Failed Logins` - Проверка количества ошибочных попыток входа
- `System Updates` - Проверяется все ли системные пакеты обновлены
- `Running Services` - Проверка количества запущенных сервисов, если больше 16 то это уже не хорошо
- `Port Security` - Проверяеются открытые порты, если их много, то это тоже не хорошо
- `Disk Usage` - Проверяем доступное место на диске
- `Memory Usage` - Проверяем количество использованной оперативной памяти
- `CPU Usage` - Проверяем нагрузку на CPU, если большая нагрузка, то это тоже повод задуматься
- `Sudo Logging` - Проверяем включение/отключение логирование sudo команд
- `Password Policy` - Проверяется настройка парольных политик
- `SUID Files` - Поиск наличия SUID файлов

---

## Шаг 9: Включение логирования всех `sudo` команд

Для включения логирования необходимо отредактировать файл конфигурации `sudo`. Для этого, достаточно выполнить команду

```bash
sudo visudo
```

Которая откроет редактор с конфигурацией утилиты. По умолчанию открывается редактор `nano`. После этого необходимо прописать следующие строки, после блока со всеми настройками `Defaults`

```
Defaults logfile=/var/log/sudo.log
Defaults log_input,log_output
```

---

## Шаг 10: Настройка автоматического обновления пакетов безопасности

Чтобы настроить автоматическое обновление пакетов безопасности на большинстве дистрибутивов Linux достаточно установить и сконфигурировать приложения `unattended-upupgrades` (Для дистрибутивов Debian/Ubuntu) или `dnf-automatic` (для Fedora/RHEL), а так же включить их, настроив сами сервиса или таймеры. Ты можешь впоследствии кастомизировать утилиты, включив только обновление пакетов безопасности.

Установка и настройка для Debian/Ubuntu

1. Нужно установить пакет `unattended-upgrades`
   ```bash
   sudo apt update
   sudo apt install unattended-upgrades
   ```
2. Теперь нужно вконфигурировать утилиту
   ```bash
   sudo dpkg-reconfigure --priority=low unattended-upgrades
   ```
  Появится окно подтверждения на котором нужно будет ответить `yes` для включения автоматического обновления.
3. Проверяем конфигурацию. Для этого можно запустить обновление в режиме `--dry-run`
   ```bash
   sudo unattended-upgrades --dry-run --debug
   ```

Установка и настройка для Fedora и RHEL

1. Устанавливаем пакет `dnf-automatic`
   ```bash
   sudo dnf install dnf-automatic
   ```
2. Настраиваем файл конфигурации `dnf-automatic.conf`
   ```bash
   sudo nano /etc/dnf/automatic.conf
   ```
  там нужно будет прописать строки
   ```text
   apply_updates = yes
   upgrade_type = security
   ```
3. Нужно включить и запустить таймер
   ```bash
   sudo systemctl enable --now dnf-automatic.timer
   ```
4. И проверить статус работы
   ```bash
   systemctl status dnf-automatic.timer
   ```

Помимо этого можно сконфигурировать

- Оповещения по Email. Для обоих систем можно активировать алерты по факту действий. Для этого необходимо отредактировать файл `/etc/apt/apt.conf.d/50unattended-upgrades` и установить адрес для отправки сообщений системному администратору
- Автоматическая перезагрузка. Так же можно настроить и ее, но тут нужно быть осторожным, и не желательно включать эту функцию в продакшен среде.
- А так же нужно контролировать файл логирования после обновлений. Например для `unattended-upgrades` этот файл распологается тут `/var/log/unattended-upgrades`
