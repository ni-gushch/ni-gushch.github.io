+++
title = "Получение сертификатов в k3s (k8s) через cert manager."
description = "Способ автоматизировать процесс получения сертификатов для локального контура с использованием cert manager и DNS01 challenge."
date = 2025-02-12
draft = false

[taxonomies]
tags = ["kubernetes","k3s", "k8s", "certmanager", "letsencrypt"]
[extra]
keywords = "kubernetes, k3s, k8s, cert-manager, letsencrypt"
#thumbnail = "ferris-gesture.png"
#toc = true
series = "kubernetes"
+++

Наличие SSL сертификатов в наше время является неотъемлемой частью безопасности разворачиваемых ресурсов. А когда я занялся организацией своего сервера и поднял k3s кластер, то сразу задумался о том, как обеспечить Web сервисы валидными сертификатами.

Приведу "маленькую историческую справку", о том, что такое SSL сертификаты, зачем они нужны, и что такое доверенные центры сертификации. Дальше это пригодится.

## SSL сертификаты и HTTPs соединение

**SSL-сетификат** - это цифровой документ, который подтверждает подлинность web-ресурса и шифрует данные, передаваемые между клиентом и сервером. Он подтверждает, что клиент общается именно с тем сайтом, который заявлен, а не с поддельным. Потому что скомпроментировать сертификат достаточно сложно, в самом простом варианте необходимо пробраться на серверную часть ресурса и украсть секретную часть ключа. 

**SSL (Secure Sockets Layer)** - технология, которая обеспечивает безопасное соединение. В последнее время стали чаще использовать аббревеатуру TLS (Transport Layer Security). Этот протокол защищает информацию, которую пользователь отправляет на сторону сервера или получает от него. Например логины и пароли, данные банковских карт. Если же не использовать шифрование, то обычный HTTP трафик очень легко перехватить и прочитать содержимое пакета.

**HTTPS (HyperText Transfer Protocol Secure)** - это защищенная версия протокола HTTP, использующая сертификаты и технологии SSL/TLS для шифрования данных.

## Доверенные центры сертификации (CA)

Центры сертификации (Certificate authorities) - это организации, которые занимаются выдачей SSL-сертификатов. Их задачей является проверить, что пользователь, запросивший сертификат, является владельцем домена, на который запрашивается сертификат, и подтверждают подлинность. Другими словами эти организации выступают своего рода гарантами взаимосвязи домена и владельца, а в подтверждении выдают подписанный документ (с печатью) - сертификат. Приведу список известных центров сертификации: 

- Let's Encrypt (который использоваться в статье)
- DegiCert
- Comodo
- GlobalSign

Как происходит обмен данными:

1. **Клиент (браузер)** запрашивает соединение с сервером (например, при переходе на сайт).
2. **Сервер** отправляет клиенту свой SSL-сертификат.
3. **Клиент** проверяет сертификат (может проверить самостоятельно или обратиться к центру сертификации, который выдал документ):
   - Доверен ли центр сертификации?
   - Не истек ли срок действия сертификата?
   - Соответствует ли доменное имя сертификата запрашиваемому сайту?
4. Если проверка прошла успешно, **клиент и сервер** устанавливают безопасное соединение с использованием шифрования (например, с помощью алгоритмов RSA или ECDHE).
5. После этого данные передаются в зашифрованном виде. Например, если вы вводите пароль на сайте, он будет зашифрован и расшифрован только на сервере.

## Как получить SSL сертификат

Есть несколько путей получения сертификата. Кратко рассмотрим их.

### Создание самоподписных сертификатов

Делается это достаточно легко, через утилиту `openssl` (linux). Используя всего несколько команд мы получаем 2 файлика, сам сертификат и ключ. Их уже можно привязывать к веб серверу. Весь процесс выдачи описывать не вижу смысла, по этому поводу есть куча статей, например вот [эта](https://habr.com/ru/articles/352722/).

Какие минусы у этого подхода.

- придется прописывать сертификат в каждом браузере, на каждом устройстве. Потому что мы будем являться CA, а весь мир не знает о существовании Иванова Ивана, который считает себя доверенным центром сертификации. Поэтому при входе на такой сайт браузер будет ругаться по причине невозможности проверить сам центр сертификации. 
- Следить за валидностью и временем жизни придется самостоятельно. И вовремя обновлять. Можно сделать себе заметку в календаре, но не редко встречал ситуации в больших компаниях, когда забывали выпустить новые сертификаты и работа вставала на пол дня.

### Использование утилиты `certbot`

Эта утилита позволит в автоматическом режиме получить сертификат **Let's Encrypt** под указанный домен. Можно получать сертификаты как на конкретные домены, так и по схеме wildcart (когда можно получить один сертификат на все возможные поддомены). Например если запросить ssl для `example.com`, то он будет доступен только для него, а если же запросить wildcart `*.example.com`, то его можно использовать как для `one.example.com`, так и для `two.example.com` и даже для `one.two.example.com`. 

Процесс получения сертификата достаточно прост. Необходимо установить ее, а затем используя команду `certbot certonly {...params...}`. Для более подробной информации о процессе получения можно почитать [эту статью](https://habr.com/ru/articles/270273/)

Следует упомянуть о двух способах получения (acme challenges)

- **HTTP01 challenge** - процесс, при котором на хосте, где запускатеся утилита, создается endpoint `{requested_domain}/.well-known/acme-challenge/{ID}`, который ссылается на содержимое файла, созданного `certbot` в котором хранится секретный ключ. `certbot` отправляет callback запрос на сторону Let'sEncrypt. В свою очередь Let'sEncrypt должен вызвать наш домен с указанным адресом, чтобы получить и проверить секретный ключ. Если проверка пройдет успешно, то в ответ отправляется созданный сертификат и ключ. В этом случае необходимо, чтобы сервис, для которого выдается сертификат был виден из глобальной сети. Либо же нужно создать "сервис заглушку", который не будет настоящим сервисом, а просто будет отдавать по указанному пути данные секретного ключа. Кстати в статье приведенной ранее есть некое описание процесса, позволяющего сделать такой "сервис заглушку".
- **DNS01 challenge** - в этой ситуации нет необходимости чтобы сервис, для которого запрашивается сертификат, светился в глобальной сети. Но здесь нужен доступ к PublicAPI сервиса, где был куплен искомый домен. При таком запросе, мы должны указать логин пароль или же апи ключ от PublicAPI, чтобы `certbot` смог создать TXT записть для запрашиваемого домена. После этого сервис Let'sEncrypt обращается по указанному домену чтобы прочесть ключ из созданной TXT записи. После проверки мы так же получаем сертификат и секретный ключ.

Использование `certbot` может решить огромное количество проблем, но все же остаются минусы:

- отслеживать время жизни сертификата все еще приходится самостоятельно. Начиная с января 2025 года Let'Encrypt закрыла проект оповещения о окончании действия сертификата через email рассылку, потому что для них это стало дорого.
- каждый раз необходимо вручную запрашивать новые сертификаты. Конечно можно автоматизировать этот процесс через другие утилиты, но наша цель интегрироваться в k3s кластер чтобы все работало из коробки. Да, я ленивый.

### Использование сервиса `cert-manager`

И вот добрались до того решения, который сейчас используется в моем кластере. Сервис `cert-manager` забирает на себя всю работу по выдаче, отслеживанию, обновлению и присвоению сертификатов. От пользователя требуется только настроить процесс выдачи и просто прописывать в ingress новых сервисов указание использования tls соединения. И `cert-manager` увидит создание нового ingress с tls сразу получит валидный сертификат и присвоит его сервису.

Рассмотрим процесс установки и настройки. Для начала неоходимо наличие кластера k3s или k8s (или другого кубера). Установленая утилита `helm` для управления helm чартами.

Для удобства я создал на машине с кластером папку `/home/ms/helms`, где хранятся все values.yaml и другие настройки helm чартов. Переходим в эту папку и начинаем выполнять команды

```bash
helm repo add jetstack https://charts.jetstack/io
helm repo update
helm pull jetstack/cert-manager
```

Команды выше добавляют репозиторий `jetstack` в котором расположен необходимый нам чарт. Далее загружаем чарт `cert-manager` используя команду `pull`.

Проверяем, что архив был загружен и разархивируем его. Необходимо обратить внимание на версию чарта, на момент написания статьи это версия `1.16.3`.

```bash
ls -la
tar zxf cert-manager-v1.16.3.tgz
rm cert-manager-v1.16.3.tgz
cp cert-manager/values.yaml cert-manager-values.yaml
```

Я использовал DNS01 challenge для получения сертификатов. Потому что кластер кубера находится в локальной сети и сервисы не выходят в глобальную сеть. Заморачиваться с отдельным "сервисом-заглушкой", который бы помог использовать HTTP01 не стал. Мне показалось через DNS будет проще. Но столкнулся с проблемой, когда при запросе сертификата `cert-manager` бесконечно висел с ошибкой 

```
DNS record for xxx not yet propagated
```

Потратил на решение этой проблемы около 3 дней, пока не нашел Issue на GitHub с решением. [Сама ссылка на Issue](https://github.com/cert-manager/cert-manager/issues/5042) и еще одна ссылка с [решением](https://github.com/cert-manager/cert-manager/issues/5515#issuecomment-1479054700)

Необходимо подправить файл values.yaml, найти следующие строки и исправить в таком виде

```
crds:
  enabled: true

extraArgs:
  - --enable-certificate-owner-ref=true
  - --dns01-recursive-nameservers-only
  - --dns01-recursive-nameservers=8.8.8.8:53,1.1.1.1:53

prometheus:
  enabled: true
  servicemonitor:
    enabled: true
```

Далее устанавлием сам сервис `cert-manager` в кластер.

```bash
helm upgrade --install cert-manager -f cert-manager-values.yaml cert-manager/
```

Для того чтобы использовать DNS challenge нам нужно получить API key провайдера, где был приобретен домен. Настройка для многих зарубежных провайдеров схожа, но я использую reg.ru. И для него нет стандартной реализации webhook для `cert-manager`. Поэтому воспользуемся еще одним [сервисом](https://github.com/flant/cert-manager-webhook-regru). В этом репозитории лежит реализация webhook для использования DNS challenge через reg.ru. В README репозитория есть инструкция по использованию, оттуда можно взять все, кроме процесса создания файла сертификата. Я предпочитаю все таки использовать wildcard сертификат, а выдавать для каждого домена в отдельности.

Теперь нужно настроить такой объект как `ClusterIssuer`, это объект который отвечает за настройки процесса выдачи сертификатов. Для этого создадим отдельную папку `/home/ms/ci` и в этой папке создадим файл `cert-manager-issuer.yml`

```yaml
---
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod-issuer
spec:
  acme:
    email: <YOUR_EMAIL>
    server: https://acme-v02.api.letsencrypt.org/directory
    privateKeySecretRef:
      name: <SUPER_SECRET_KEY>
    solvers:
      - dns01:
          webhook:
            config:
              # здесь могут быть настройки для другого webhook провайдера.
              regruPasswordSecretRef:
                name: regru-password
                key: REGRU_PASSWORD
            # groupName should be the same as `groupName.name` in `values.yaml` file.
            groupName: acme.regru.ru
            solverName: regru-dns
---
```

Пример `solver` DNS01 для cloudflare

```yaml
        - dns01:
          cloudflare:
            email: xxx
            apiTokenSecretRef:
              name: cloudflare-token-secret
              key: cloudflare-token
```

Если не хочется заморачиваться с получением сертификата через DNS challenge, то можно использовать HTTP challenge. Для этого в секции solvers необходимо прописать следующее.

```yaml
- http01:
        # The ingressClass used to create the necessary ingress routes
        ingress:
          serviceType: ClusterIP
          ingressClassName: traefik
```

Но следует учесть, чтобы этот способ работал, домен должен быть доступен из внешней сети. Либо необходимо использовать отедельный сервис, который сможет подтвердить право на владение ресурсом.

Применяем параметры через команду:

```bash
kubectl apply -f cert-manager-issuer.yml
```

Теперь настраиваем файл ingress на примере сервиса portainer. Yaml файлы для ingress удобно хранить в отдельной папке, например `/home/ms/ingress`. В качестве ReverseProxy используется Traefik, так как он был по умолчанию установлен при развертывании k3s.

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: portainer-ingress
  namespace: default
  labels:
    app: portainer
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: websecure
    # указываем название созданного ранее ClusterIssuer
    cert-manager.io/cluster-issuer: letsencrypt-prod-issuer
spec:
  rules:
  - host: portainer.EXAMPLE.COM
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: portainer
            port:
              number: 9000
  ingressClassName: traefik
  tls:
  - hosts:
      - portainer.EXAMPLE.COM
    secretName: portainer-ssl
```

Применяем параметры ingress:

```bash
kubectl apply -f portainer-ingress.yml
```

На этом все. После применения настроек ingress `cert-manager` автоматически их найдет, и начнет процесс выдачи сертификата под указанный домен в файле ingress в секции `tls.hosts`
